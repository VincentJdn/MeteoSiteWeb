// ✅ Prévisions: maintenant -> demain 23:00, AGRÉGÉES par blocs de 3h + séparation jour
function renderForecastNowToTomorrow23_every3h_withDayBreak(times, temp, rain, wind, wx, now){
  const nowMs = now.getTime();

  const end = new Date(now);
  end.setDate(end.getDate() + 1);
  end.setHours(23,0,0,0);
  const endMs = end.getTime();

  const timeline = document.getElementById("timeline");
  timeline.innerHTML = "";

  // Seuil minuit pour afficher "DEMAIN"
  const todayMidnight = new Date(now);
  todayMidnight.setHours(0,0,0,0);
  const tomorrowMidnight = new Date(todayMidnight);
  tomorrowMidnight.setDate(tomorrowMidnight.getDate() + 1);
  const tomorrowMs = tomorrowMidnight.getTime();

  // ✅ On construit de vrais blocs 3h, avec cumul pluie etc.
  const blocks = build3hBlocks(times, temp, rain, wind, wx, nowMs, endMs);

  let insertedTodayPill = false;
  let insertedTomorrowPill = false;

  let firstIso = null, lastIso = null;

  for (const b of blocks){
    if(!insertedTodayPill){
      timeline.insertAdjacentHTML("beforeend", `
        <div class="dayBreak" aria-label="Jour courant">
          <div class="dayPill">AUJOURD’HUI</div>
        </div>
      `);
      insertedTodayPill = true;
    }

    if (!insertedTomorrowPill && b.startMs >= tomorrowMs){
      timeline.insertAdjacentHTML("beforeend", `
        <div class="dayBreak" aria-label="Changement de jour">
          <div class="dayLine"></div>
          <div class="dayPill">DEMAIN</div>
        </div>
      `);
      insertedTomorrowPill = true;
    }

    if(!firstIso) firstIso = b.startIso;
    lastIso = b.endIso;

    const col = tempColor(b.tempAvg);
    const wxInfo = wmoToIcon(b.wxCode);

    // Libellé horaire: "09:00–12:00"
    const label = `${hourLabel(b.startIso)}–${hourLabel(b.endIso)}`;

    timeline.insertAdjacentHTML("beforeend", `
      <div class="slot">
        <div class="tHour">${label}</div>

        <div class="topRow">
          <div class="tTemp" style="color:${col}">${fmt(b.tempAvg,0)}°</div>
          <div class="wx" title="${wxInfo.label}">
            <div class="wxIcon">${wxInfo.icon}</div>
            <div class="wxText">${wxInfo.label}</div>
          </div>
        </div>

        <!-- ✅ pluie = cumul 3h -->
        <div class="mini"><span class="dot"></span> ${fmt(b.rainSum,2)} mm / 3h</div>
        <!-- ✅ vent = max 3h -->
        <div class="mini"><span class="arrow">➝</span> ${fmt(b.windMax,0)} km/h</div>
      </div>
    `);
  }

  const tlRange = document.getElementById("tlRange");
  tlRange.textContent = (firstIso && lastIso)
    ? `${dateLabel(firstIso)} ${hourLabel(firstIso)} → ${dateLabel(lastIso)} ${hourLabel(lastIso)}`
    : "—";
}


/**
 * Construit des blocs de 3 heures “réels” à partir des séries horaires :
 * - pluie : somme des 3 heures (mm / 3h) ✅
 * - température : moyenne des 3 heures
 * - vent : max des 3 heures
 * - code météo : heuristique (heure la plus pluvieuse, sinon "pire" code)
 */
function build3hBlocks(times, temp, rain, wind, wx, fromMs, toMs){
  // 1) on garde uniquement les indices dans [fromMs, toMs]
  const idx = [];
  for(let i=0;i<times.length;i++){
    const ms = new Date(times[i]).getTime();
    if(ms < fromMs) continue;
    if(ms > toMs) break; // times trié
    idx.push(i);
  }
  if(!idx.length) return [];

  // 2) point de départ = prochaine heure pleine ">= now"
  // (Open-Meteo est au pas horaire : 13:00, 14:00, ...)
  // Si tu veux vraiment “aligner à 3h” (00/03/06...), dis-le : on le fait aussi.
  let startI = idx[0];

  const blocks = [];
  for(let p=startI; p < times.length; p += 3){
    const msStart = new Date(times[p]).getTime();
    if(msStart < fromMs) continue;
    if(msStart > toMs) break;

    const groupIdx = [p, p+1, p+2].filter(j => j < times.length);
    // stop si on sort de la plage
    if(new Date(times[groupIdx[0]]).getTime() > toMs) break;

    // On prend fin = dernière heure du bloc (ex: 09–12 => fin=12:00)
    // (si il manque des heures, on s’adapte)
    const endIndex = groupIdx[groupIdx.length-1];
    const msEnd = new Date(times[endIndex]).getTime();
    if(msEnd > toMs) break;

    // ---- agrégations ----
    let tSum = 0, tCount = 0;
    let rainSum = 0;
    let windMax = 0;

    // Pour choisir l’icône : heure la plus pluvieuse, sinon “pire” code
    let maxRainHour = -1;
    let maxRain = -1;
    let worstCode = -1;

    for(const j of groupIdx){
      const t = temp[j];
      const r = rain[j];
      const w = wind[j];
      const c = wx[j];

      if(typeof t === "number"){ tSum += t; tCount++; }
      if(typeof r === "number"){
        rainSum += r;                 // ✅ cumul des mm de chaque heure
        if(r > maxRain){ maxRain = r; maxRainHour = j; }
      }
      if(typeof w === "number"){ windMax = Math.max(windMax, w); }

      // “pire” code : heuristique simple (orage > neige > pluie > brouillard > nuages > soleil)
      if(Number.isFinite(c)){
        const severity = wmoSeverity(c);
        if(severity > worstCode) worstCode = severity;
      }
    }

    const tempAvg = tCount ? (tSum / tCount) : null;

    // code retenu :
    // - s’il y a de la pluie sur le bloc, icône = l’heure la plus pluvieuse
    // - sinon icône = “pire condition” du bloc
    let wxCode = null;
    if(maxRain > 0 && maxRainHour >= 0){
      wxCode = wx[maxRainHour];
    } else {
      // On reprend un code réel du bloc correspondant au max de sévérité
      wxCode = pickWorstCode(groupIdx, wx);
    }

    // libellé : on affiche une plage "start–end+1h" plus intuitive
    // ex group [09,10,11] => "09:00–12:00"
    const startIso = times[groupIdx[0]];
    const endPlus1 = new Date(times[endIndex]);
    endPlus1.setHours(endPlus1.getHours() + 1);
    const endIso = endPlus1.toISOString(); // ISO UTC; mais on n’utilise que hourLabel() qui affiche en local

    blocks.push({
      startIso,
      endIso,
      startMs: msStart,
      endMs: endPlus1.getTime(),
      tempAvg,
      rainSum,
      windMax,
      wxCode
    });
  }

  return blocks;

  // --- helpers ---
  function wmoSeverity(code){
    const c = Number(code);
    if(!Number.isFinite(c)) return 0;
    // orages
    if(c === 95 || c === 96 || c === 99) return 6;
    // neige/averses neige
    if([71,73,75,77,85,86].includes(c)) return 5;
    // pluie / bruine / averses pluie / verglaçant
    if([51,53,55,56,57,61,63,65,66,67,80,81,82].includes(c)) return 4;
    // brouillard
    if(c === 45 || c === 48) return 3;
    // nuages
    if(c === 3) return 2;
    if(c === 2) return 1.5;
    if(c === 1) return 1;
    if(c === 0) return 0.5;
    return 0;
  }

  function pickWorstCode(groupIdx, wx){
    let best = null;
    let bestSev = -1;
    for(const j of groupIdx){
      const c = wx[j];
      const sev = wmoSeverity(c);
      if(sev > bestSev){ bestSev = sev; best = c; }
    }
    return best;
  }
}
